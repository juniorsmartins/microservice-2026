server:
  port: ${SERVER_PORT:9060}

spring:
  application:
    name: api-notifications
  profiles:
    active: default

---
spring:
  config:
    activate:
      on-profile: default

  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:db-notifications}?serverTimezone=UTC
    username: ${MARIADB_USER:mariadb}
    password: ${MARIADB_PASSWORD:mariadb}

  jpa:
    hibernate:
      ddl-auto: none
    defer-datasource-initialization: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
        connection:
          isolation: 2
        cache:
          use_second_level_cache: false
          use_query_cache: false
    open-in-view: false
    show-sql: true

  flyway:
    # --- Controle de Execução (Obrigatório) ---
    enabled: true # Liga o Flyway no Spring Boot
    baseline-on-migrate: true # a mais segura e usada por 99 % das empresas
    baseline-version: 0       # ou 1, depende da sua convenção
    baseline-description: "Initial structure"
    # --- Localização e Nomenclatura dos Scripts ---
    locations: classpath:flyway # Onde o Flyway procura os scripts (padrão: db/migration)
    sql-migration-prefix: V # Prefixo padrão para migrações versionadas
    sql-migration-separator: __ # Separador entre versão e nome no arquivo SQL
    sql-migration-suffixes: .sql # Suporta apenas arquivos com sufixo .sql
    # --- Validação e Segurança (Produção) ---
    validate-on-migrate: true # [SEGURANÇA] Valida checksums antes de migrar. Antes de aplicar novas migrations, valida que todas as já aplicadas batem com os scripts no classpath. Protege contra alguém apagar ou alterar um script antigo.
    clean-disabled: true # [SEGURANÇA] DESABILITA o comando 'clean' em produção! Impede acidental flyway:clean em prod.
    out-of-order: false # [SEGURANÇA] Não permite migrações fora de ordem
    target: latest # Garantir que migre sempre para a última versão
    connect-retries: 3 # Número de tentativas de conexão antes de falhar
    connect-retries-interval: 5
    # --- Tabela de Schema (Opcional, mas Útil) ---
    table: flyway_schema_history # padrão já é esse, mas deixar explícito.
    schemas: db-notifications # Defina explicitamente o schema/banco. Importante quando há múltiplos databases.
    encoding: UTF-8 # Encoding dos arquivos SQL

  kafka:
    bootstrap-servers: kafka-1:9092,kafka-2:9092,kafka-3:9092
    schema.registry.url: http://schema-registry:8081
    consumer:
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: io.confluent.kafka.serializers.KafkaAvroDeserializer

      # === Estratégia de rebalance ===
      partition.assignment.strategy: org.apache.kafka.clients.consumer.CooperativeStickyAssignor
      group-id: ${spring.application.name}-v1
      group.instance.id: ${spring.application.name}-${STATEFULSET_POD_INDEX:0}
      session.timeout.ms: 45000

      # === Forma de leitura e garantia de entrega ===
      auto-offset-reset: latest
      enable-auto-commit: false
      # enable-auto-commit false precisa de tópico DLT

      # === Resiliência (funciona com Retries) ===
      request-timeout-ms: 45000

      # === Performance ===
      max-poll-records: 500
      max.poll.interval.ms: 600000

      # === Schema Registry ===
      properties:
        specific.avro.reader: true

    topic:
      events:
        customer-created: events.customer-created-v1
      min.insync.replicas: 2

  mail:
    host: smtp.gmail.com
    port: 587
    username: dev.juniorsmartins@gmail.com
    password: nrqd slph cgpq tlit
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true

